eldar04, noa.margulis
Eldar Amar (214728131), Noa Margulis (208635334)
EX: 2

FILES:
uthreads.cpp
Makefile – the makefile

REMARKS:

ANSWERS:

1. siglongjmp and sigsetjmp
    a. sigsetjmp sets a save point for the current user-thread.
        It saves the PC, SP and CPU registers in a struct to be used when siglongjmp is called.

        siglongjmp swaps between user-threads. Given the state of a thread, saved in the struct mentioned before,
        the function swaps the current running thread with all the necessary data stored in the struct.
        It causes the program to jump to the code where sigsetjmp was called.
        It also sets the corresponding sigsetjmp return value to be an integer value of choice ‘val’.

    b. The sigsetjmp function receives a sort of Boolean value for
        whether to keep the masking of the current thread when returning to that point using siglongjmp.
        So the user has the ability to save the current masking for the thread or to forget about them.


2. One use of user-level threads would be running a program that performs multiple tasks at the same time
    where the tasks are not I/O related.

    User-level threads are a reasonable choice here because it has less overhead
    when compared to kernel-level threads or running multiple processes.

    In addition, the usual problem with user-level threads, which is that I/O operations halt the entire process,
    doesn't hold here since, as mentioned, the tasks are computational.


3.
    Advantages:
        Each process has its own address space, which provides better isolation.

        Since processes are isolated, they are more robust against errors and memory corruption.
        One process crashing does not take down the entire application.

        Threads share the same process resources,
        which means that resource limits set for the process apply to all threads.
        Having multiple processes allows different resources for each tab and more resources in total.

    Disadvantages:
        Creating a new process involves more overhead than creating a thread.

        Inter-process Communication is more complex and slower compared to threads, which can share memory directly.


4. while running a progress such as a random app like “shadow”,
    a command from the user, given by the keyboard to the shell,
    causes a sequence of interrupts and signals that end the process.
    An interrupt is a signal to the CPU indicating that an event has occurred,
    and it results in changes in the sequence of instructions that is executed by the CPU.
    signals are generated by the os and received and handled by a process.

    Elaboration on Interrupts and Signals Involved in this example:

    1. Keyboard Interrupt:
        external interrupts of hardware - user (us) pressed a key on keyboard
         - When we press Enter after typing the command "run Shotwell" for running the app and "ps -a" for data abaot
          the process, and "kill pid" for teminate it - we initiat the  the run of intercepts that will cause
          the process to stop
         the keyboard sends an interrupt signal to the CPU indicating that input is available.

    2. Operating System:
        The OS receives the interrupt from the keyboard.
        The interrupt handler in the OS - processes this and retrieves the input from the keyboard buffer.

    3. Shell (Command Line Interpreter):
        The shell reads the input (the kill pid command) and interprets it, then issues a system call to the OS to
        send a signal to the process with the specified PID.

    4. Signals and Handling (signals are generated by the os and received and handled by a process):
       - The kill command sends a signal to the specified process. By default, kill sends the SIGTERM signal.
       - SIGTERM (signal number 15) is a termination signal that requests a process to terminate.
       - The process (Shotwell, in this case) receives the SIGTERM signal.

    5. Process (Shotwell):
       Upon receiving SIGTERM, Shotwell can handle this signal by performing cleanup operations
       (saving state, releasing resources, etc.) and then terminate itself.
       If the process does not handle SIGTERM, it will be terminated by the OS by default.


5. The difference between ‘real’ and ‘virtual time’:
    Real Time
    Definition: Real time refers to the actual time as experienced in the physical world.
    Example:
        a Real-Time System?
        The term “real-time system” refers to any information processing system with hardware and software components
        that perform real-time application functions and can respond to events within predictable and specific time
         constraints. Common examples of real-time systems include air traffic control systems, process control
          systems, and autonomous driving systems.

    Virtual Time
    Definition: Virtual time is a conceptual representation of time used within a computer.
    Virtual time is a concept used in computer simulation, distributed systems, and virtual reality to model and manage
     the flow of time differently from real-world or wall-clock time. It allows systems to simulate events,
     processes, or actions in a controlled time frame, which can be faster, slower, paused, or even reversed
      relative to real time.
    Example:
        1. Virtual Machine Clock: In the context of VMs,
        each VM operates in a simulated environment where the clock is managed by the VM manager.
        This virtual clock may not run at the same rate as the host system's real clock.
        2. Simulation and Modeling: Virtual time allows for the simulation of complex systems,
        such as weather patterns, stock market dynamics,
        or the behavior of large networks. By speeding up time, researchers can observe long-term trends and
         patterns within a short real-world time frame.

