eldar04, noa.margulis
Eldar Amar (214728131), Noa Margulis (208635334)
EX: 2

FILES:
uthreads.cpp
Makefile – the makefile

REMARKS:

ANSWERS:

1. siglongjmp and sigsetjmp
    a. sigsetjmp sets a save point for the current user-thread.
        It saves the PC, SP and CPU registers in a struct to be used when siglongjmp is called.

        siglongjmp swaps between user-threads. Given the state of a thread, saved in the struct mentioned before,
        the function swaps the current running thread with all the necessary data stored in the struct.
        It causes the program to jump to the code where sigsetjmp was called.
        It also sets the corresponding sigsetjmp return value to be an integer value of choice ‘val’.

    b. The sigsetjmp function receives a sort of Boolean value for
        whether to keep the masking of the current thread when returning to that point using siglongjmp.
        So the user has the ability to save the current masking for the thread or to forget about them.


2. One use of user-level threads would be running a program that performs multiple tasks at the same time
    where the tasks are not I/O related.

    User-level threads are a reasonable choice here because it has less overhead
    when compared to kernel-level threads or running multiple processes.

    In addition, the usual problem with user-level threads, which is that I/O operations halt the entire process,
    doesn't hold here since, as mentioned, the tasks are computational.


3.
    Advantages:
        Each process has its own address space, which provides better isolation.

        Since processes are isolated, they are more robust against errors and memory corruption.
        One process crashing does not take down the entire application.

        Threads share the same process resources,
        which means that resource limits set for the process apply to all threads.
        Having multiple processes allows different resources for each tab and more resources in total.

    Disadvantages:
        Creating a new process involves more overhead than creating a thread.

        Inter-process Communication is more complex and slower compared to threads, which can share memory directly.


4. while running a progress such as a random app like “shadow”,
    a command from the user, given by the keyboard to the shell,
    causes a sequence of interrupts and signals that end the process.
    An interrupt is a signal to the CPU indicating that an event has occurred,
    and it results in changes in the sequence of instructions that is executed by the CPU.

    Elaboration on Interrupts and Signals Involved:

    1. Keyboard Interrupt:
        external interrupts of hardware - user (us) pressed a key on keyboard
         - When we press Enter after typing the command,
         the keyboard sends an interrupt signal to the CPU indicating that input is available.

    2. Operating System:
        The OS receives the interrupt from the keyboard.
        The interrupt handler in the OS processes this and retrieves the input from the keyboard buffer.

    3. Shell (Command Line Interpreter):
        The shell reads the input (the kill pid command) and interprets it.
        The shell then issues a system call to the OS to send a signal to the process with the specified PID.

    4. Signals and Handling (signals are generated by the os and received and handled by a process):
       - The kill command sends a signal to the specified process. By default, kill sends the SIGTERM signal.
       - SIGTERM (signal number 15) is a termination signal that requests a process to terminate.
       - The process (Shotwell, in this case) receives the SIGTERM signal.

    5. Process (Shotwell):
       Upon receiving SIGTERM, Shotwell can handle this signal by performing cleanup operations
       (saving state, releasing resources, etc.) and then terminate itself.
       If the process does not handle SIGTERM, it will be terminated by the OS by default.


5. The difference between ‘real’ and ‘virtual time’:
    Real Time
    Definition: Real time refers to the actual time as experienced in the physical world.
    Example:
        Real-Time Monitoring Systems: An example of a real-time system is a heart rate monitor used in a hospital.
        The device collects data on a patient's heart rate and displays it immediately.
        If the heart rate goes beyond a certain threshold, an alert is triggered instantly to notify medical staff.

    Virtual Time
    Definition: Virtual time is a conceptual representation of time used within a computer.
    Example:
        Virtual Machine Clock: In the context of VMs,
        each VM operates in a simulated environment where the clock is managed by the VM manager.
        This virtual clock may not run at the same rate as the host system's real clock.
